<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bernoulli Data Type: Bernoulli maps</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bernoulli Data Type
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_BERNOULLI_MAP.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Bernoulli maps </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The bernoulli map quantifies a certain kind of approximation error that is compatible with many algorithms, particularly data types that depend on hashing.</p>
<p>Suppose we have a <em>latent</em> function <code>p : X -&gt; Y</code> and an observale approximation or noisy version of <code>p</code>, denoted by <code>p* : X -&gt; Y</code>, such that <code>p*(x) != p(x)</code> with probability <code>e(x)</code>, where <code>{e(x) : x in X}</code> are apriori statistically independent random variables.</p>
<p>When we observe <code>p*</code>, we know that it is a noisy model of some function <code>X -&gt; Y</code>, but we do not know which one with certainty. If we are given no other prior information, then the best estimator of <code>p</code> is <code>p*</code>.</p>
<p>Let the functions of type <code>X -&gt; Y</code> be named <code>p1, p2, ..., pn</code>, where <code>n</code> is the total number of functions in <code>X -&gt; Y</code>, which if no other information is given, is given by the cardinality of <code>X -&gt; Y</code>, which is just <code>n = |Y|^|X|</code>.</p>
<p>Let us show the confusion matrix for <code>p1, p2, p3, p4</code> (<code>n=4</code>, e.g., <code>bool -&gt; bool</code>), where the rows represent the latent functions, and the columns represent the observed functions that may be generated from the latent function, say by introducing some error or rate distortion.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">latent \ observed   </th><th class="markdownTableHeadNone"><code>p1</code>   </th><th class="markdownTableHeadNone"><code>p2</code>   </th><th class="markdownTableHeadNone"><code>p3</code>   </th><th class="markdownTableHeadNone"><code>p4</code>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>p1</code>   </td><td class="markdownTableBodyNone"><code>q11</code>   </td><td class="markdownTableBodyNone"><code>q12</code>   </td><td class="markdownTableBodyNone"><code>q13</code>   </td><td class="markdownTableBodyNone"><code>q14</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>p2</code>   </td><td class="markdownTableBodyNone"><code>q21</code>   </td><td class="markdownTableBodyNone"><code>q22</code>   </td><td class="markdownTableBodyNone"><code>q23</code>   </td><td class="markdownTableBodyNone"><code>q24</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>p3</code>   </td><td class="markdownTableBodyNone"><code>q31</code>   </td><td class="markdownTableBodyNone"><code>q32</code>   </td><td class="markdownTableBodyNone"><code>q33</code>   </td><td class="markdownTableBodyNone"><code>q34</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>p4</code>   </td><td class="markdownTableBodyNone"><code>q41</code>   </td><td class="markdownTableBodyNone"><code>q42</code>   </td><td class="markdownTableBodyNone"><code>q43</code>   </td><td class="markdownTableBodyNone"><code>q44</code>   </td></tr>
</table>
<p>In the matrix above, <code>qij</code> represents the probability that function <code>pi</code> is observed as function <code>pj</code>. Since each row must sum to 1, there are at maximum of <code>n * (n-1)</code> degrees of freedom, which in this case is <code>4 * (4-1) = 12</code>.</p>
<p>We call this degree-of-freedom the <em>order</em> of the Bernoulli Model for <code>X -&gt; Y</code>. In many cases, the order is 1, e.g., where most of the probability is assigned to the diagonal, and the off-diagonal elements are nearly zero (or zero) but all equal.</p>
<p>Since we are only given <code>p*</code>, we do not know which <code>p</code> is the true latent function. We say that <code>p*</code> is a <em>Bernoulli approximation</em> of <code>p</code>, and we deote this by writing <code>p* ~ bernoulli&lt;X-&gt;Y&gt;{p}</code>, i.e., we observe <code>p*</code> but we know that it is a random observation from a conditional distribution where we are conditioning on the latent function <code>p</code> to generate <code>p*</code>.</p>
<p>If we observe a realization of <code>p* ~ bernoulli&lt;X-&gt;Y&gt;{p}</code>, where <code>p</code> is latent, and we know that it is a Bernoulli approximation, then we say that <code>p*</code> is of the type </p><div class="fragment"><div class="line">X -&gt; bernoulli&lt;Y&gt;</div>
</div><!-- fragment --><p>Normally the order of the Bernoulli Model is not that important, but it may be, e.g., if we are trying to estimate the latent function <code>p</code> from <code>p*</code>, and we know that the order is 1, then we can estimate the confusion matrix more easily given an i.i.d. sample of observations.</p>
<p>A more <em>interesting</em> property, that can be read off the confusion matrix, is the entropy of the distribution <code>bernoulli&lt;X-&gt;Y&gt;</code>. This is given by </p><div class="fragment"><div class="line">H(bernoulli&lt;X-&gt;Y&gt;) = -sum_{i=1}^n sum_{j=1}^n qij log(qij)</div>
</div><!-- fragment --><p> where <code>qij</code> is the probability that <code>pi</code> is observed as <code>pj</code>.</p>
<p>We can also consider the conditional entropy distribution, <code>bernoulli&lt;X-&gt;Y|pi&gt;</code>, where <code>pi</code> is the latent function. This is given by </p><div class="fragment"><div class="line">H(bernoulli&lt;X-&gt;Y|pi&gt;) = -sum_{j=1}^n qij log(qij)</div>
</div><!-- fragment --><p> where <code>qij</code> is the probability that <code>pi</code> is observed as <code>pj</code>.</p>
<p>Often, we apriori <em>know</em> the confusion matrix, or at least various properties of this matrix, as a result of the distortion being the result of some known process, e.g., a noisy channel, or a noisy sensor, or a noisy measurement. A noisy channel also includes things like a program that introduces some loss as a way of compressing the data, or it may be the result of some homomorphic encryption scheme or a homomophorism for an oblivious data structure where we represent values as the product of trapdoors, one-way hashes.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Bernoulli Maps</h1>
<p>A Bernoulli Map is just a way of generating a Bernoulli approximation of a function. By the equivalence that data is code and code is data, any function can be represented as a data structure, and any data structure can be represented as a function. Therefore, theoretically, we can model any data structure as a map, and then we can generate a Bernoulli approximation of that map, which means we have a Bernoulli approximation of the data structure.</p>
<p>Often, we have more efficient and interesting ways to generate particular kinds of Bernoulli approximations of data structures. Probably, the most popular example are sets, like Bloom filters.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Set-indicator function &lt;tt&gt;1_A : X -&gt; bool&lt;/tt&gt;</h2>
<p>The set-indicator function for <code>A</code>, denoted by <code>1_A</code>, where <code>1_A(x)</code> is <code>true</code> if <code>x</code> is in <code>A</code>, and <code>false</code> otherwise. When we apply a Bernoulli Model to <code>1_A</code>, we get a function of type <code>X -&gt; bernoulli&lt;bool&gt;</code>. We observe <code>bernoulli&lt;X-&gt;bool&gt;{1_A}</code> but we do not know <code>A</code> with certainty. This is a <em>Bernoulli approximation</em> of <code>1_A</code>, and common examples of this kind of approximation are <em>bloom filters</em> and <em>counting bloom filters</em>. In this project, we introduce the Bernoulli Map, which is an algorithm that can generate any kind of approximation of computable functions, including set-indicator functions.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Primality test: &lt;tt&gt;is_prime : integer -&gt; bernoulli&lt;bool&gt;&lt;/tt&gt;</h2>
<p>We know how to exactly determine whether an integer is prime. We can, for instance, check for divisibility by all integers less than the integer. There are many ways to more efficiently compute this, but the point is that we know how to compute it exactly.</p>
<p>However, the function is still <em>latent</em> in the sense that the time required to compute it exactly for any input of interest is prohibitive, and so in practice we do not know its extension. It is still, in this sense, latent.</p>
<p>So, instead, we can use a randomized algorithm to estimate the function and be able to compute it for any desired input in a reasonable amount of time.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
The Miller-Rabin primality test</h3>
<p>The Miller-Rabin primality test is based on the concept of Fermat's Little Theorem, which states that if <code>p</code> is a prime number and <code>a</code> is any positive integer less than <code>p</code>, then <code>a^(p-1)</code> is congruent to 1 modulo <code>p</code>.</p>
<p>The Miller-Rabin test works by randomly selecting values of <code>a</code> and checking whether the congruence holds. If the congruence fails for a particular <code>a</code>, then <code>p</code> is definitely not prime. However, if the congruence holds for some <code>a</code>, then <code>p</code> may or may not be prime but we say that it is prime, which has some specifiable probability of error (false positive rate).</p>
<p>In essence, a particular seed value (for the PRNG) draws a sample function, a Bernoulli map, from <code>is_prime* ~ bernoulli&lt;integer -&gt; bool&gt;{is_prime}</code>.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Computational basis</h1>
<p>If we have a set of functions <code>F = { f1, ..., fk }</code>, then we can define a Bernoulli model over <code>F</code> by simply generating realizations of <code>bernoulli{f1}, ... bernoulli{fk}</code> which we may denote as <code>bernoulli{F}</code>.</p>
<p>For instance, it may be desirable to support both <code>in</code> and <code>==</code> for sets. One approach is to generate a Bernoulli aproximation for each element in <code>F</code>. However, if we define <code>==</code> in terms of <code>in</code>, then that <em>induces</em> a Bernoulli Model of <code>==</code> through its dependence on <code>in</code>.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Regular types</h1>
<p>It is interesting to note that Bernoulli Models are not in general regular types, since it is often the case that, say, a Bernoulli set <code>A</code> can have countably infinite representations, and it is impossible (in general) to determine if two Bernoulli sets are the same.</p>
<p>This does not even entertain the discussion about which latent set is being approximately modeled by a Bernoulli set, which can of course also vary. If we consider this perspective, then equality on Bernoulli sets vs sets is not of type </p><div class="fragment"><div class="line">(bernoulli&lt;set&gt;, set) -&gt; bool</div>
</div><!-- fragment --><p> but of type </p><div class="fragment"><div class="line">(bernoulli&lt;set&gt;, set) -&gt; bernoulli&lt;bool&gt;</div>
</div><!-- fragment --><p> and likewise for other variations on this pattern, i.e., we can only say what the probability that a Bernoulli set represetns a given latent set. This is normally a much less interesting and informative question than set-membership, but it is still a question that can be asked. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
