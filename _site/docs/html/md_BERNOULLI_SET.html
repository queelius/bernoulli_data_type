<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bernoulli Data Type: Bernoulli set</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bernoulli Data Type
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_BERNOULLI_SET.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Bernoulli set </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Let <code>F = array&lt;bool,N&gt;</code> be the set of all arrays of <code>N</code> Boolean values. Consider the Boolean algebra </p><div class="fragment"><div class="line">(F, +, *, ~, F{<span class="keyword">false</span>}, F{<span class="keyword">true</span>})</div>
</div><!-- fragment --><p> where <code>false</code> denotes the array of <code>N</code> <code>false</code> values and <code>F{true}</code> denotes the array of <code>N</code> <code>true</code> values. The <code>+</code> and <code>*</code> operators are defined as element-wise <code>or</code> and <code>and</code> respectively. The <code>~</code> operator is defined as element-wise <code>not</code>.</p>
<p>Suppose the <code>contains</code> predicate function </p><div class="fragment"><div class="line">contains : (F,int) -&gt; bool</div>
</div><!-- fragment --><p> is defined as </p><div class="fragment"><div class="line"><span class="keyword">auto</span> contains(<span class="keyword">auto</span> A, <span class="keyword">auto</span> i) { <span class="keywordflow">return</span> i &gt;= 0 &amp;&amp; i &lt; N &amp;&amp; A[i]; }</div>
</div><!-- fragment --><p> Likewise, suppose the equality operator </p><div class="fragment"><div class="line">== : (F, F) -&gt; bool</div>
</div><!-- fragment --><p> is defined as </p><div class="fragment"><div class="line"><span class="keyword">auto</span> operator==(<span class="keyword">auto</span> lhs, <span class="keyword">auto</span> rhs) {</div>
<div class="line">    std::all_of(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(),</div>
<div class="line">        [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) { return x == y; });</div>
<div class="line">}</div>
</div><!-- fragment --><p>Consider a Bernoulli Boolean value. Since there are only two possible values, <code>{true, false}</code>, we have the follow situations to consider. First, let <code>xj</code> indicate the <code>j</code>th element of the array <code>x</code> and let <code>Pr{E}</code> denote the probability of the event <code>E</code>.</p>
<p>0. <code>Pr{bernoulli&lt;bool&gt;{xj} == xj} = 1</code> where <code>xj</code> is either <code>true</code> or <code>false</code>. This is a zeroth-order Bernoulli model, i.e., <code>bernoulli&lt;bool,0&gt;</code> is equivalent to <code>bool</code> and an array of them is equivalent to an array of <code>bool</code>. This is like a <em>perfect channel</em> where no noise is introduced.</p>
<ol type="1">
<li><code>Pr{bernoulli&lt;bool&gt;{xj} == xj} = p</code> for all <code>j</code> and <code>0 &lt; p &lt; 1</code>. This is a first-order Bernoulli model. This is equialent to a <em>binary symmetric channel</em> where noise is i.i.d. and independent of the input. We denote each of these as <code>bernoulli&lt;bool,1&gt;</code> and an array of them as <code>array&lt;bernoulli&lt;bool,1&gt;,N&gt;</code>. Note that this is equivalent to <code>bernoulli&lt;array&lt;bool,N&gt;&gt;</code> and there is technically only one parameter, <code>p</code>, in the confusion matrix that needs to be estimated.</li>
<li><code>Pr{bernoulli&lt;bool&gt;{xj} == xj|xj == TRUE} = p1</code> and <code>Pr{bernoulli&lt;bool&gt;{xj} == xj|xj == FALSE} = p2</code> for all <code>j</code> and <code>p1 != p2</code> and both are non-zero and also not equal to one. This is a second-order Bernoulli model where the probability of error is different for <code>true</code> and <code>false</code> but the same for all indexes. This is like a <em>binary asymmetric channel</em> where noise is introduced that is dependent on the input.</li>
<li><code>Pr{bernoulli&lt;bool&gt;{xj} == xj|xj == TRUE} = p(xj|TRUE)</code> and <code>Pr{bernoulli&lt;bool&gt;{xj} == xj|xj == FALSE} = p(xj|FALSE)</code>. This is a higher-order Bernoulli model where the probability of error may be different for each index and for each value. The maximum order of this model is <code>2^N(2^N-1)</code>.</li>
</ol>
<p>Regardless, when we have these Bernoulli Booleans, this induces a Bernoulli Model of the Boolean algebra. We denote this mathematical structure the Bernoulli set model, <code>bernoulli&lt;set&lt;X&gt;&gt;</code>.</p>
<p>A natural way to construct a Bernoulli set is to allow false positives on non-members but no false negatives, such as in the Bloom filter. However, there is also an opportunity to allow for false negatives by introducing a rate distrotion either due to time complexity constraints or space constraints. We consider a Bernoulli set model, named <code>rd_ph_filter</code> and <code>rd_hash_set</code>, that allows for false positive and false negatives, and also an entropy coder in which the probability of a membership test is implicitly represented by prefix-free codes such that the probability of an error varies for each element being tested. The end result is a very compact data structure that, for the given compression rate, has the lowest probability of error. (Expected loss is minimized.)</p>
<p>Even a Bernoulli set that, say, only allows for false positives, can <em>generate</em> a Bernoulli set that allows for false negatives. For example, consider the Bloom filter. The Bloom filter is a Bernoulli set that allows for false positives but no false negatives. However, if we take the complement of the Bloom filter, we get a Bernoulli set that allows for false negatives but no false positives. In general, set-theoretic operations on Bernoulli sets can generate Bernoulli sets of a different or higher order. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
