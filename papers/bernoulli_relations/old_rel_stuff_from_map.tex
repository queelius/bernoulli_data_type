\documentclass[ ../main.tex]{subfiles}
\providecommand{\mainx}{..}
\begin{document}
\section{Generalizating \emph{maps} to \emph{relations}}
\label{sec:relations}


TODO: This section needs to be a separate paper. We can, however, show how the approximate map may be used to \emph{optimally} implement the approximate relation. Actually, the approximate relation, like the approximate map, do not necessarily have a strong selling point unless the value is small compared to the key, in which case the key takes up most of the space and we still achieve something by allowing false positives on the key and then mapping to a value.

TODO: separately, what about an OBLIVIOUS TYPE? In an approximate set, the elements are instances of an OBLIVIOUS TYPE because:
(1) You don't know the element x is in the set until you specifically ask if x is in the set. That is, you can't iterate over the set, that is, just by looking at the collection of bits that make up the set, you can't infer what the elements are. You actually have to ask for x specifically, and only then is it revealed to be a member or not. The less you can tell about the elements of the set by looking at the collection of bits that make up the set, the better. In a Perfect Hash Filter, we can know some things... like we can know that there are N or fewer elements if the perfect hash function is 1,...,N. The load factor may not be known, though (although a low load factor makes the distribution of bit lengths assign greater probability to smaller values), so we can only say with certainty that there are N or fewer. Another thing we know is that each actual element of the set

The relational model manages data using a structure and language consistent with first-order predicate logic\cite{} where data is represented in terms of tuples grouped into relations. A database organized according to the relational model is a relational database.

In the relational model, related records are linked together with a \emph{key}. The purpose of the relational model is to provide a declarative method for specifying data and queries: users directly state what information the database contains and what information they want from it, and let the implementation ake care of describing data structures for storing the data and retrieval procedures for answering queries.

Most relational databases use the SQL data definition and query language; these systems implement what can be regarded as an engineering approximation to the relational model. A table in an SQL database schema corresponds to a predicate variable; the contents of a table to a relation; key constraints, other constraints, and SQL queries correspond to predicates. However, SQL databases deviate from the relational model in many details, and Codd fiercely argued against deviations that compromise the original principles.[4]

The golden rule is ``every non-key attribute must provide a fact about the key, the whole key, and nothing but the key.''


NOTE: Also cannot do any sort of computations on entire columns, or subsets of columns, unless the corresponding keys are also known.

NOTE: Mention how this is an especially appropriate choice of a relational data structure in the case of Encrypted Search, since it allows \emph{oblivious} relations.

If a key needs to map to a variable-sized \emph{array} of elements, that constitutes \emph{multiple} facts about the key. In this case, it is probably better to use a key-value map, where the \emph{value} is an array. An array does too much. It has multiple facts and it stores the order (which is not related to the relation itself). And the performance is poor (see above).


\Cref{tbl:relation} depicts a \emph{relation} where the \emph{key} column consists of unique identifiers and the \emph{values} column must consist of (possibly repeated) elements from $\mathbb{Z}$.
\begin{table}[h]
\centering
\caption{A table representing a relation of $p$ tuples each with $n$ attributes about each key}
\label{tbl:relation}
\begin{tabular}{|c c c c|} 
\hline
key & attribute$_1$ & $\cdots$ & attribute$_n$\\
\hline
    $k_1$ & $a_{1 1}$ & $\cdots$ & $a_{1 n}$\\
    $k_2$ & $a_{2 1}$ & $\cdots$ & $a_{2 n}$\\
    $\vdots$ & $\vdots$& $\vdots$ & $\vdots$\\
    $k_p$ & $a_{p 1}$ & $\cdots$ & $a_{p n}$\\
\hline
\end{tabular}
\end{table}

The \emph{keys} in a relation is denoted by
\begin{equation}
    \Dom(\Relation)\,.
\end{equation}

A single map may, of course, represent a relation by having keys (unique identifiers) map to tuples. For example, \cref{tbl:relation} may be given by
\begin{equation}
    \Fun = \left\{
        \left(k_j, \left(a_{j 1}, \cdots, a_{j n}\right)\right) \colon j = 1,\ldots,p
    \right\}\,.
\end{equation}

\begin{table}[h]
\centering
\caption{A table representing a relation of $p$ tuples each with $n$ elements}
\label{tbl:relation_tuple_value}
\begin{tabular}{|c c|} 
\hline
key & values\\
\hline
    $k_1$ & $a_{1 1},\cdots,a_{1 n}$\\
    $k_2$ & $a_{2 1},\cdots,a_{2 n}$\\
    $\vdots$ & $\vdots$\\
    $k_p$ & $a_{p 1},\cdots,a_{p n}$\\
\hline
\end{tabular}
\end{table}

If we code each tuple element independently, and compute the entropy of the $j$-th attribute to be $\mu_j$, then the information-theoretic lower-bound is given by
\begin{equation}
    -\log_2 \varepsilon + \sum_{j=1}^{n} \mu_j \; \si{bits \per tuple}\,.
\end{equation}

An alternative way to construct a relation is given by
\begin{equation}
    \Fun{f}[k] =
    \left\{
        \left(k_j, a_{j k}\right) \colon j = 1,\ldots,p
    \right\}
\end{equation}
for $k=1,\ldots,n$. That is, for each of the $n$ attributes, generate a map.
The tuple in the relation with a unique id $x$ is then given by $\Fun{f}[1](x),\ldots,\Fun{f}[n](x)$.

\begin{table}[h]
\centering
\caption{A table representing a relation of $p$ tuples each with $n$ elements}
\label{tbl:relation2}
\begin{tabular}{|c c|} 
\hline
key & attribute$_1$\\
\hline
    $k_1$ & $a_{1 1}$\\
    $k_2$ & $a_{2 1}$\\
    $\vdots$ & $\vdots$\\
    $k_p$ & $a_{p 1}$\\
\hline
\end{tabular}
$\cdots$
\begin{tabular}{|c c|} 
\hline
key & attribute$_n$\\
\hline
    $k_1$ & $a_{1 n}$\\
    $k_2$ & $a_{2 n}$\\
    $\vdots$ & $\vdots$\\
    $k_p$ & $a_{p n}$\\
\hline
\end{tabular}
\end{table}

Using a map for each attribute in a relation is generally more flexible, e.g., one may add or remove attributes about a relation by adding or removing maps. Multiple relations may also be joined or combined in various ways. However, since we assume the maps are not enumerable (e.g., countably infinite), then the full relational model is not possible since we may only retrieve a tuple by its (unique) key.

The information-theoretic lower-bound of this approach is given by
\begin{equation}
\label{eq:lb_join}
    -\log_2 \varepsilon_2 \cdots \varepsilon_n + \sum_{j=1}^{n} \mu_j \; \si{bits \per tuple}\,,
\end{equation}
which has a false positive rate $\varepsilon_2 \cdots \varepsilon_n$ and thus obtains an absolute efficiency of $1$. \Cref{eq:lb_join} may be rewritten as
\begin{equation}
    \sum_{j=1}^{n} \left[\log_2 \frac{1}{\varepsilon_j} + \mu_j\right] \; \si{bits \per tuple}\,.
\end{equation}
As $\varepsilon_j \to 1$ for $j=1,\ldots,n$, the result converges to
\begin{equation}
    \sum_{j=1}^{n} \mu_j \; \si{bits \per tuple}\,.
\end{equation}
We could use an \emph{approximate set}\cite{aset} of the keys with a false positive rate $\varepsilon$, and use $n$ approximate maps. As $\varepsilon_j \to 1$ for $j=1,\ldots,n$, the false positive rate of the relation converges to $\varepsilon$ and the bit length converges to
\begin{equation}
    -\log_2 \varepsilon + \sum_{j=1}^{n} \mu_j \; \si{bits \per tuple}\,.
\end{equation}

If we relax the assumption that each exact map in the relation share the same set of keys, then the information-theoretic lower-bound is no longer obtainable by this approach. However, it allows for relations with \emph{null} values that do not require any bits to code and generally allows for more flexibility, i.e., adding or removing columns, tuples, or even individual tuple elements by adding or removing maps from the relation.

There are advantages and disadvantages to each approach. The first approach, where the keys map to actual tuples, is computationally the most efficient since only one lookup must be performed. Additionally, in practice, greater efficiency is obtained since each map has a bit length with some constant overhead cost (that only asymptotically vanishes as the number of keys in the map goes to infinity).

%\begin{equation}
%    -\beta (n \log_2 \varepsilon) + \sum_{j=1}^{n} \mu_j \; \si{bits \per tuple}\,,
%\end{equation}



The latter approach that uses multiple maps all indexed by the same key can more fully implement the relational logic. Moreover, if each approximate map has some false positive rate less than $1$, say a false positive rate that is independently useful, then there are fewer restrictions on how the approximate maps may be combined to generate new table views, joins, or compositions.

However, note that since we have the restriction that we may only index based off of a single key, we cannot do certain types of joins.


\begin{table}[h]
\centering
\caption{A derived \emph{attribute} based on the \emph{composition} $\operatorname{g}(\text{attribute$_2$})$.}
\label{tbl:relation_derived}
\begin{tabular}{|c c|} 
\hline
key & derived attribute\\
\hline
    $k_1$ & $\operatorname{g} \circ \ExactMap{2}(a_{1 2})$\\
    $k_2$ & $\operatorname{g} \circ \ExactMap{2}(a_{2 2})$\\
    $\vdots$ & $\vdots$\\
    $k_p$ & $\operatorname{g} \circ \ExactMap{2}(a_{p 2})$\\
\hline
\end{tabular}
\begin{tabular}{|c c|} 
\hline
key & $\operatorname{g}(\text{key})$\\
\hline
    $k_1$ & $v_1$\\
    $k_2$ & $v_2$\\
    $\vdots$ & $\vdots$\\
    $k_t$ & $v_t$\\
\hline
\end{tabular}
\end{table}


A \emph{relation} may exist in the context of other \emph{relations}. In the full relational model, these relations may be related, combined, and viewed in many different ways. However, ...




\subsection{Abstract data type}
The abstract data type of the approximate relation is given by the following definition.
\begin{definition}
\label{def:approx_rel}
Given a relation $\Relation{R}$, we denote any approximate relation of $\Relation{R}$ by $\ARelation{R}$. The abstract data type of the \emph{approximate relation} $\ARelation{R}$ where the set of keys is given by $\X$, the set of attribute \emph{names} is given by $\Set{Y}$, and the set of attributes is given by $\Set{A} = \Set{Y}_1 \times \cdots \times \Set{Y}_n$ has the following operations defined:
\begin{align}
    &\GetAttributeNames \colon \left[\ARelation{R}\right] \mapsto \left[\Set{Y}\right]\,,\\
    &\HasKey \colon \left[\ARelation{R}\right] \times \X \mapsto \Bool\,,\\
    &\GetAttributes \colon \left[\ARelation{R}\right] \times \X \mapsto \Set{A} + \{ \Null \}\,\,\\
    &\FalsePositiveRate \colon \left[\ARelation{R}\right] \mapsto [0,1]\,,\\
    &\FalseNegativeRate \colon \left[\ARelation{R}\right] \mapsto [0,1]\,.
\end{align}

The \HasKey function tests whether a particular \emph{key} is in the relation, i.e., \HasKey{$\Arelation{}$,$x$}, $x \in \X$, returns \True if $x \in \Keys(\Arelation{})$ and otherwise returns \False.

The \GetAttributes function retrieves the \emph{attributes}, a set of iterable key-value pairs, where the key is the \emph{name} of the attribute, about a particular \emph{key}. If a key has no associated attributes, \nullvalue is returned.

The relation $\ARelation{R}$ is an approximate relation of $\Relation{}$ with a false positive rate $\varepsilon$ and false negative rate $\eta$ if the following conditions hold:
\begin{enumerate}[(i)]
    \item Let a key that is selected uniformly at random from the universe $\Set{X}$ be denoted by $\RV{X}$. If $\RV{X}$ is a member of $\Keys(\Relation{R})$, it is not a member of $\Keys(\ARelation{R})$ with a probability $\eta$,
    \begin{equation}
        \Prob{\neg \HasKey\!\left(\Arelation{},\rv{X}\right) \Given \HasKey\!\left(\Relation{},\rv{X}\right)} = \eta\,.
    \end{equation}
    
    \item Let an element that is selected uniformly at random from the universe $\X$ be denoted by $\RV{X}$. If $\RV{X}$ is \emph{not} a member of $\Keys(\Relation{})$, it is a member of $\Keys(\ARelation{R})$ with a probability $\varepsilon$,
    \begin{equation}
        \Prob{\HasKey\!\left(\ARelation{R},\RV{X}\right) \Given \neg \HasKey\!\left(\Relation{R},\RV{X}\right)} = \varepsilon\,.
    \end{equation}
    
    \item The false positive rate function is given by
    \begin{equation}
         \FalsePositiveRate(\ARelation{R}) = \varepsilon\,.
    \end{equation}

    \item The false negative rate function is given by
    \begin{equation}
         \FalseNegativeRate(\ARelation{R}) = \eta\,.
    \end{equation}    

\end{enumerate}
\end{definition}


A more full relational model is given by the following.
\begin{definition}
\begin{align}
    &\JoinRelations \colon \left[\ARelation{R}\right] \times \left[\ARelation{R}\right] \mapsto \left[\ARelation{R}\right]\,,\\
    &\RemoveAttribute \colon \left[\ARelation{R}\right] \times \Set{Y} \mapsto \left[\ARelation{R}\right]\,,\\
    &\AddAttribute \colon \left[\ARelation{R}\right] \times \Set{Y} \mapsto \{\True,\False\}\,,\\
    &\SetAttributeName \colon \left[\ARelation{R}\right] \times \Set{Y} \times \Y \mapsto \Bool\,,\\
    &\GetSubRelation \colon \left[\ARelation{R}\right] \times \PowerSet(\Set{Y}) \mapsto \left[\ARelation{R}\right]\,,\\
    &\Merge \colon \left[\ARelation{R}\right] \times \left[\ARelation{R}\right] \mapsto \left[\ARelation{R}\right]\,,\\
    &\AddDerivedAttribue \colon \left[\ARelation{R}\right] \times \left[\APFun{f}\right] \times \OrderedList[\Set{Y}] \times \left[\Set{Y}\right]\,.
\end{align}
\end{definition}




TODO: Add (relation, foreign key), give name. Now, another function on a table (relation). get attribute(relation, key)

TODO: The add linked attribute by key is a special linking feature. Since the \emph{key} is not necessarily stored anywhere in the table, but is only used at \emph{query} time to map to the correct row (with a false positive / false negative rate), the add link by key feature allows the key used at query time to be used at query time. Maybe operator overload this, i.e., a general attribute (that no other attribute may be named), say ``key'', that may be used in many of those functions.

\AddLinkByKey(RelationToAddTo,Relation,Attribute)


\end{document}