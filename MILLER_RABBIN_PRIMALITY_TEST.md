# Bernoulli maps generated by special algorithms

In other documents, we have discussed the concept of a Bernoulli map. In this document,
we will discuss how to generate Bernoulli maps for certain special algorithms.


## Primality testing: `is_prime : integer -> bernoulli<bool>`

We know how to exactly determine whether an integer is prime. We can, for instance,
check for divisibility by all integers less than the integer. There are many
ways to more efficiently compute this, but the point is that we know how to
compute it exactly.

However, the function is still *latent* in the sense that the time required to
compute it exactly for any input of interest is prohibitive, and so in practice we do
not know its extension. It is still, in this sense, latent.

So, instead, we can use a randomized algorithm to estimate the function and be able
to compute it for any desired input in a reasonable amount of time. 

### The Miller-Rabin primality test
The Miller-Rabin primality test is based on the concept of Fermat's Little Theorem,
which states that if `p` is a prime number and `a` is any positive integer less than
`p`, then `a^(p-1)` is congruent to 1 modulo `p`.

The Miller-Rabin test works by randomly selecting values of `a` and checking whether
the congruence holds. If the congruence fails for a particular `a`, then `p` is
definitely not prime. However, if the congruence holds for some `a`, then `p` may
or may not be prime but we say that it is prime, which has some specifiable
probability of error (false positive rate).

In essence, a particular seed value (for the PRNG) draws a sample function, a Bernoulli
map, from `is_prime* ~ bernoulli<integer -> bool>{is_prime}`.


## Sorted: `is_sorted : X -> bernoulli<bool>`

I can't say this is the most valuabel algorithm, since checking for sortedness
is fast. The only exception is if difficult or impossible to observe all the elements
in the sequence, e.g., if we are streaming the elements and we only have a limited
amount of memory to store them, or indeed, we are only given a sample of the sequence
from which we must determine if the sequence is sorted.

So, with those caveats in mind, suppose we have a sequence of `n` elements.
If we want to determine if the sequence is sorted, we may do a single pass
through the sequence, checking that `x[i] < x[i+1]` for `i=1,...,n-1`.

However, `O(n)` may be too slow for whatever reason.
Alternatively, we could *sample* (without replacement) a subset and determine if
the subset is sorted and use that information to estimate, with some probability
of error, that the larger collection is sorted.

Assume the sequence contains values sampled uniformly from a value type `X`.

Say we have a sequence of 3 Boolean values, 0 or 1, and we check the
first two values for sortedness. What is the probability the sequence is sorted
if we assume the Boolean values are sampled uniformly at random?

There are `2^n = 2^4 = 16` possible sequences over Boolean values.

```
{
        (0, 0, 0, 0),
        (0, 0, 0, 1),
        (0, 0, 1, 0),
        (0, 0, 1, 1),
        (0, 1, 0, 0),
        (0, 1, 0, 1),
        (0, 1, 1, 0),
        (0, 1, 1, 1),
        (1, 0, 0, 0),
        (1, 0, 0, 1),
        (1, 0, 1, 0),
        (1, 0, 1, 1),
        (1, 1, 0, 0),
        (1, 1, 0, 1),
        (1, 1, 1, 0),
        (1, 1, 1, 1)
}
```

Of these, those that are in order, assuming `0 < 1`, are given by

```
{
    (0, 0, 0, 0),
    (0, 0, 0, 1),
    (0, 0, 1, 1),
    (0, 1, 1, 1),
    (1, 1, 1, 1)
}
```


### Case m=1
If we sample `m=1`, this is *always* sorted. Recall that we assume that the
collection has elements sampled uniformly from `X := bool`. So, what is
the probability that the larger collection is ordered?

If we sampled a 0, we look at all the ordered sub-samples that contain 0 and
then divide it by the total number of sub-samples that contain 0.
There are 4 ordered sub-samples that contain 0 and there are 15 sub-samples
that contain 0, thus the probability that the collection is sorted is given
by 4/15.

If we sampled a 1, then we see there are 4 ordered sub-samples that contain
1 and 15 sub-samples that contain 1. Again, the probability comes out to
4/15.

In each case, the probability that `is_sorted` outputs an erroneous value
is 11/15. This calls for a larger sample.

### Case m=2
If we sample `m=2`, what is the probability that the larger collection is ordered
if the sample is ordered? The possible ordered sub-samples are given by

```
{
    (0,0),(0,1),(1,1)
}
```

If we sampled a (0,0), we look at all the ordered sub-samples that contain
(0,0) and then divide it by the total number of sub-samples that contain `(0,0)`.
There are 3 ordered sub-samples that contain `(0,0)` and there are 8 sub-samples
that contain $(0,0), thus the probability that the collection is sorted is given
by 3/8.

If we sampled a `(0,1)`, then we see there are 3 ordered sub-samples that contain
`(0,1)` and 11 sub-samples that contain `(0,1)`, thus the probability that the collection is sorted is given by 3/11.

If we sampled a `(1,1)`, then we see there are 3 ordered sub-samples that contain
`(1,1)` and 8 sub-samples that contain `(1,1)`, thus the probability that the collection is sorted is given by 3/8.

The probability of error is still probably too large.

At the extreme case, if we sample `m=4`, the probability of error is 0 since this reduces
to the exact `is_ordered` test function.

