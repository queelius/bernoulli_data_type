In other documents, we have discussed the concept of a Bernoulli map. In this document, we will discuss how to generate Bernoulli maps for certain special algorithms.\hypertarget{md_MILLER_RABBIN_PRIMALITY_TEST_autotoc_md21}{}\doxysection{Primality testing\+: $<$tt$>$is\+\_\+prime \+: integer -\/$>$ bernoulli$<$bool$>$$<$/tt$>$}\label{md_MILLER_RABBIN_PRIMALITY_TEST_autotoc_md21}
We know how to exactly determine whether an integer is prime. We can, for instance, check for divisibility by all integers less than the integer. There are many ways to more efficiently compute this, but the point is that we know how to compute it exactly.

However, the function is still {\itshape latent} in the sense that the time required to compute it exactly for any input of interest is prohibitive, and so in practice we do not know its extension. It is still, in this sense, latent.

So, instead, we can use a randomized algorithm to estimate the function and be able to compute it for any desired input in a reasonable amount of time.\hypertarget{md_MILLER_RABBIN_PRIMALITY_TEST_autotoc_md22}{}\doxysubsection{The Miller-\/\+Rabin primality test}\label{md_MILLER_RABBIN_PRIMALITY_TEST_autotoc_md22}
The Miller-\/\+Rabin primality test is based on the concept of Fermat\textquotesingle{}s Little Theorem, which states that if {\ttfamily p} is a prime number and {\ttfamily a} is any positive integer less than {\ttfamily p}, then {\ttfamily a$^\wedge$(p-\/1)} is congruent to 1 modulo {\ttfamily p}.

The Miller-\/\+Rabin test works by randomly selecting values of {\ttfamily a} and checking whether the congruence holds. If the congruence fails for a particular {\ttfamily a}, then {\ttfamily p} is definitely not prime. However, if the congruence holds for some {\ttfamily a}, then {\ttfamily p} may or may not be prime but we say that it is prime, which has some specifiable probability of error (false positive rate).

In essence, a particular seed value (for the PRNG) draws a sample function, a Bernoulli map, from {\ttfamily is\+\_\+prime$\ast$ $\sim$ bernoulli$<$integer -\/$>$ bool$>$\{is\+\_\+prime\}}.\hypertarget{md_MILLER_RABBIN_PRIMALITY_TEST_autotoc_md23}{}\doxysection{Sorted\+: $<$tt$>$is\+\_\+sorted \+: X -\/$>$ bernoulli$<$bool$>$$<$/tt$>$}\label{md_MILLER_RABBIN_PRIMALITY_TEST_autotoc_md23}
I can\textquotesingle{}t say this is the most valuabel algorithm, since checking for sortedness is fast. The only exception is if difficult or impossible to observe all the elements in the sequence, e.\+g., if we are streaming the elements and we only have a limited amount of memory to store them, or indeed, we are only given a sample of the sequence from which we must determine if the sequence is sorted.

So, with those caveats in mind, suppose we have a sequence of {\ttfamily n} elements. If we want to determine if the sequence is sorted, we may do a single pass through the sequence, checking that {\ttfamily x\mbox{[}i\mbox{]} $<$ x\mbox{[}i+1\mbox{]}} for {\ttfamily i=1,...,n-\/1}.

However, {\ttfamily O(n)} may be too slow for whatever reason. Alternatively, we could {\itshape sample} (without replacement) a subset and determine if the subset is sorted and use that information to estimate, with some probability of error, that the larger collection is sorted.

Assume the sequence contains values sampled uniformly from a value type {\ttfamily X}.

Say we have a sequence of 3 Boolean values, 0 or 1, and we check the first two values for sortedness. What is the probability the sequence is sorted if we assume the Boolean values are sampled uniformly at random?

There are {\ttfamily 2$^\wedge$n = 2$^\wedge$4 = 16} possible sequences over Boolean values.


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{        (0, 0, 0, 0),}
\DoxyCodeLine{        (0, 0, 0, 1),}
\DoxyCodeLine{        (0, 0, 1, 0),}
\DoxyCodeLine{        (0, 0, 1, 1),}
\DoxyCodeLine{        (0, 1, 0, 0),}
\DoxyCodeLine{        (0, 1, 0, 1),}
\DoxyCodeLine{        (0, 1, 1, 0),}
\DoxyCodeLine{        (0, 1, 1, 1),}
\DoxyCodeLine{        (1, 0, 0, 0),}
\DoxyCodeLine{        (1, 0, 0, 1),}
\DoxyCodeLine{        (1, 0, 1, 0),}
\DoxyCodeLine{        (1, 0, 1, 1),}
\DoxyCodeLine{        (1, 1, 0, 0),}
\DoxyCodeLine{        (1, 1, 0, 1),}
\DoxyCodeLine{        (1, 1, 1, 0),}
\DoxyCodeLine{        (1, 1, 1, 1)}
\DoxyCodeLine{\}}

\end{DoxyCode}


Of these, those that are in order, assuming {\ttfamily 0 $<$ 1}, are given by


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{    (0, 0, 0, 0),}
\DoxyCodeLine{    (0, 0, 0, 1),}
\DoxyCodeLine{    (0, 0, 1, 1),}
\DoxyCodeLine{    (0, 1, 1, 1),}
\DoxyCodeLine{    (1, 1, 1, 1)}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_MILLER_RABBIN_PRIMALITY_TEST_autotoc_md24}{}\doxysubsection{Case m=1}\label{md_MILLER_RABBIN_PRIMALITY_TEST_autotoc_md24}
If we sample {\ttfamily m=1}, this is {\itshape always} sorted. Recall that we assume that the collection has elements sampled uniformly from {\ttfamily X \+:= bool}. So, what is the probability that the larger collection is ordered?

If we sampled a 0, we look at all the ordered sub-\/samples that contain 0 and then divide it by the total number of sub-\/samples that contain 0. There are 4 ordered sub-\/samples that contain 0 and there are 15 sub-\/samples that contain 0, thus the probability that the collection is sorted is given by 4/15.

If we sampled a 1, then we see there are 4 ordered sub-\/samples that contain 1 and 15 sub-\/samples that contain 1. Again, the probability comes out to 4/15.

In each case, the probability that {\ttfamily is\+\_\+sorted} outputs an erroneous value is 11/15. This calls for a larger sample.\hypertarget{md_MILLER_RABBIN_PRIMALITY_TEST_autotoc_md25}{}\doxysubsection{Case m=2}\label{md_MILLER_RABBIN_PRIMALITY_TEST_autotoc_md25}
If we sample {\ttfamily m=2}, what is the probability that the larger collection is ordered if the sample is ordered? The possible ordered sub-\/samples are given by


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{    (0,0),(0,1),(1,1)}
\DoxyCodeLine{\}}

\end{DoxyCode}


If we sampled a (0,0), we look at all the ordered sub-\/samples that contain (0,0) and then divide it by the total number of sub-\/samples that contain {\ttfamily (0,0)}. There are 3 ordered sub-\/samples that contain {\ttfamily (0,0)} and there are 8 sub-\/samples that contain \$(0,0), thus the probability that the collection is sorted is given by 3/8.

If we sampled a {\ttfamily (0,1)}, then we see there are 3 ordered sub-\/samples that contain {\ttfamily (0,1)} and 11 sub-\/samples that contain {\ttfamily (0,1)}, thus the probability that the collection is sorted is given by 3/11.

If we sampled a {\ttfamily (1,1)}, then we see there are 3 ordered sub-\/samples that contain {\ttfamily (1,1)} and 8 sub-\/samples that contain {\ttfamily (1,1)}, thus the probability that the collection is sorted is given by 3/8.

The probability of error is still probably too large.

At the extreme case, if we sample {\ttfamily m=4}, the probability of error is 0 since this reduces to the exact {\ttfamily is\+\_\+ordered} test function. 